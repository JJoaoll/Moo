
pVarId :: Parser Text
pVarId = lexeme $ do
  c  <- letterChar 
  cs <- many alphaNumChar 

  return c:cs
  
  Var <$> lexeme 
  ((:) <$> letterChar <*> many alphaNumChar <?> "variable")

pFunId = Var <$> lexeme 
  ((:) <$> letterChar <*> many alphaNumChar <?> "variable")

pGlobalId = Var <$> lexeme 
  ((:) <$> letterChar <*> many alphaNumChar <?> "variable")

pTypeId = undefined
pConstrId = indefuned
pConstId = undefined
  


-- pVar, pIf, pAbs, pApp, pLet, pInt, pBool, pBin, pExpr :: Parser Expr

-- if a then b else c -- If-expression
pIf = do
  void (symbol "if")
  if_ <- pExpr

  void (symbol "then")
  then_ <- pExpr
  void (symbol "else")
  else_ <-  pExpr

  return $ G.EIf if_ then_ else_


-- fun x => y : a -> b   -- Abstraction
pAbs = do 
  void (symbol "fun")
  G.EVar name <- pVar

  void (symbol "=>")
  body <- pExpr

  return $ G.EAbs name body

-- f(x)                -- Application
pApp = do
  var <- pVar 
  void (symbol "(")
  arg <- pExpr
  void (symbol ")")
  return $ G.EApp var arg


-- let a = b in c     -- Let-binding
pLet = do 
  void (symbol "let")
  G.EVar name <- pVar

  void (symbol "=")
  value <- pExpr 

  void (symbol "in")
  body <- pExpr   

  return $ G.ELet name value body


-- 123456789 : Int    -- Integer
pInt = (G.EInt . fromInteger) <$> integer

-- True, False : Bool -- Boolean
pBool = fmap G.EBool $
  (True  <$ symbol "True") <|>
  (False <$ symbol "False")


-- x + y              -- Integer addition
-- x - y              -- Integer subtraction
--   EBin :: Oper -> Expr -> Expr -> Expr
--   EVar :: Name -> Expr
--   EIf  :: Expr -> Expr -> Expr -> Expr
--   EAbs :: Name -> Expr -> Expr
--   EApp :: Expr -> Expr -> Expr
--   ELet :: Name -> Expr -> Expr -> Expr
--   EInt :: Int  -> Expr
--   EBool:: Bool -> Expr
--   EBin :: Oper -> Expr -> Expr -> Expr
pTerm :: Parser G.Expr
pTerm = choice 
  [ parens pExpr
  , pVar 
  , pInt
  , pApp  
  ]

pBin = makeExprParser pTerm operatorTable

operatorTable :: [[Operator Parser G.Expr]]
operatorTable = 
  [ [ 
      binaryR "+" $ G.EBin G.Add
    , binaryR "-" $ G.EBin G.Sub
  ] ]

pExpr = choice 
  [ pLet
  , pBin
  , pVar
  , pIf 
  , pAbs 
  , pApp 
  , pInt
  , pBool 
  ]


-------------------------------------------------------------------------------


stringLiteral :: Parser String 
stringLiteral = char '\"' *> manyTill L.charLiteral (char '\"')

integer :: Parser Integer
integer = lexeme L.decimal

float :: Parser Double
float = lexeme L.float

signedInteger :: Parser Integer
signedInteger = L.signed sc integer

signedFloat :: Parser Double
signedFloat = L.signed sc float

-- expressions

data Expr 
  = Var String 
  | Int Int 
  | Negation Expr 
  | Sum      Expr Expr 
  | Subtr    Expr Expr 
  | Product  Expr Expr 
  | Division Expr Expr 
  deriving (Eq, Ord, Show)

pVariable :: Parser Expr 
pVariable = Var <$> lexeme
  ((:) <$> letterChar <*> many alphaNumChar <?> "variable")

pInteger :: Parser Expr 
pInteger = Int <$> lexeme L.decimal 

parens :: Parser a -> Parser a 
parens = between (symbol "(") (symbol ")")

pTerm :: Parser Expr 
pTerm = choice 
  [ parens pExpr
  , pVariable 
  , pInteger
  ]

pExpr :: Parser Expr 
pExpr = makeExprParser pTerm operatorTable

-- data Operator m a -- N.B.
--   = InfixN  (m (a -> a -> a)) -- ^ Non-associative infix
--   | InfixL  (m (a -> a -> a)) -- ^ Left-associative infix
--   | InfixR  (m (a -> a -> a)) -- ^ Right-associative infix
--   | Prefix  (m (a -> a))      -- ^ Prefix
--   | Postfix (m (a -> a))      -- ^ Postfix
--
operatorTable :: [[Operator Parser Expr]]
operatorTable = 
  [ [ prefix "-" Negation 
    , prefix "+" id 
    ] -- highest precedence
  , [ binaryL "*" Product 
    , binaryL "/" Division 
    ] 
  , [ binaryR "+" Sum 
    , binaryR "-" Subtr 
    ] -- lowest precedence
  ]

binaryR :: Text -> (Expr -> Expr -> Expr) -> Operator Parser Expr
binaryR  name f = InfixR (f <$ symbol name) 

binaryL :: Text -> (Expr -> Expr -> Expr) -> Operator Parser Expr
binaryL  name f = InfixL (f <$ symbol name) 

prefix, postfix :: Text -> (Expr -> Expr) -> Operator Parser Expr
prefix  name f = Prefix (f <$ symbol name)
postfix name f = Postfix (f <$ symbol name)



--
--
--

parens :: Parser a -> Parser a 
parens = between (symbol "(") (symbol ")")

binaryR :: Text -> (G.Expr -> G.Expr -> G.Expr) -> Operator Parser G.Expr
binaryR  name f = InfixR (f <$ symbol name) 

binaryL :: Text -> (G.Expr -> G.Expr -> G.Expr) -> Operator Parser G.Expr
binaryL  name f = InfixL (f <$ symbol name) 

prefix, postfix :: Text -> (G.Expr -> G.Expr) -> Operator Parser G.Expr
prefix  name f = Prefix (f <$ symbol name)
postfix name f = Postfix (f <$ symbol name)

globalId = lexeme $ do
  _ <- symbol "@"
  varId






pVarId :: Parser Text
pVarId = lexeme $ do
  c  <- letterChar 
  cs <- many alphaNumChar 

  return c:cs
  
  Var <$> lexeme 
  ((:) <$> letterChar <*> many alphaNumChar <?> "variable")

pFunId = Var <$> lexeme 
  ((:) <$> letterChar <*> many alphaNumChar <?> "variable")

pGlobalId = Var <$> lexeme 
  ((:) <$> letterChar <*> many alphaNumChar <?> "variable")

pTypeId = undefined
pConstrId = indefuned
pConstId = undefined
  


-- pVar, pIf, pAbs, pApp, pLet, pInt, pBool, pBin, pExpr :: Parser Expr

-- if a then b else c -- If-expression
pIf = do
  void (symbol "if")
  if_ <- pExpr

  void (symbol "then")
  then_ <- pExpr
  void (symbol "else")
  else_ <-  pExpr

  return $ G.EIf if_ then_ else_


-- fun x => y : a -> b   -- Abstraction
pAbs = do 
  void (symbol "fun")
  G.EVar name <- pVar

  void (symbol "=>")
  body <- pExpr

  return $ G.EAbs name body

-- f(x)                -- Application
pApp = do
  var <- pVar 
  void (symbol "(")
  arg <- pExpr
  void (symbol ")")
  return $ G.EApp var arg


-- let a = b in c     -- Let-binding
pLet = do 
  void (symbol "let")
  G.EVar name <- pVar

  void (symbol "=")
  value <- pExpr 

  void (symbol "in")
  body <- pExpr   

  return $ G.ELet name value body


-- 123456789 : Int    -- Integer
pInt = (G.EInt . fromInteger) <$> integer

-- True, False : Bool -- Boolean
pBool = fmap G.EBool $
  (True  <$ symbol "True") <|>
  (False <$ symbol "False")


-- x + y              -- Integer addition
-- x - y              -- Integer subtraction
--   EBin :: Oper -> Expr -> Expr -> Expr
--   EVar :: Name -> Expr
--   EIf  :: Expr -> Expr -> Expr -> Expr
--   EAbs :: Name -> Expr -> Expr
--   EApp :: Expr -> Expr -> Expr
--   ELet :: Name -> Expr -> Expr -> Expr
--   EInt :: Int  -> Expr
--   EBool:: Bool -> Expr
--   EBin :: Oper -> Expr -> Expr -> Expr
pTerm :: Parser G.Expr
pTerm = choice 
  [ parens pExpr
  , pVar 
  , pInt
  , pApp  
  ]

pBin = makeExprParser pTerm operatorTable

operatorTable :: [[Operator Parser G.Expr]]
operatorTable = 
  [ [ 
      binaryR "+" $ G.EBin G.Add
    , binaryR "-" $ G.EBin G.Sub
  ] ]

pExpr = choice 
  [ pLet
  , pBin
  , pVar
  , pIf 
  , pAbs 
  , pApp 
  , pInt
  , pBool 
  ]


-------------------------------------------------------------------------------